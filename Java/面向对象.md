# 接口

## 接口的使用

* 接口使用interface关键字来定义。
* java中，接口和类是并列的两个结构。
* 如何定义接口：定义接口中的成员。

* 在jdk7以前，接口中只能定义全局常量和抽象方法：接口中不能定义其他结构包括构造器，因此接口不能实例化。
  * 全局常量：public static final
  * 抽象方法：public abstract
* 在java开发中，接口都是通过让类去实现（implements）的方式来使用。
  * 如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化。
  * 如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍是一个抽象类。
* java类可以实现多个接口，弥补了单继承的缺点。
* 接口和接口直接也可以有继承的关系，而且可以多继承。
* 接口的使用是可以体现多态性的。
* 接口实际上可以看做是一种规范。

~~~java
public class interfaceTest {
    public static void main(String[] args) {
        Plane plane = new Plane();
        plane.fly();
        plane.stop();
    }

}
interface Flyable{
    public static final int MAX_SPEED = 7900;
    int MIN_SPEED = 0;//因为接口中的属性都是全局常量，因此可以省去public static final。

    public abstract void fly();

    void stop();//接口中的方法为抽象方法，因此可以省去public abstract
}

class Plane implements Flyable{
    @Override
    public void fly() {
        System.out.println("通过引擎起飞");
    }

    @Override
    public void stop() {
        System.out.println("驾驶员减速停止");
    }
}
~~~

## 代理模式

~~~java
package com.shy.interfa;

public class NetWorkTest {
    public static void main(String[] args) {
        Server server = new Server();
        ProxyServer proxyServer = new ProxyServer(server);
        proxyServer.browse();
    }
}

interface NetWork{
    void browse();
}
//被代理类
class Server implements NetWork{

    @Override
    public void browse() {
        System.out.println("被代理类的服务器访问");
    }
}
//代理类
class ProxyServer implements NetWork{
    private NetWork work;

    public ProxyServer(NetWork work){
        this.work = work;
    }

    public void check(){
        System.out.println("代理类进行校验");
    }
    @Override
    public void browse() {
        check();
        work.browse();
    }
}
~~~

## 工厂模式